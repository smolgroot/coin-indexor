package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"fmt"
	"strconv"
	
	"github.com/user/coin-indexer/internal/database"
	"github.com/user/coin-indexer/internal/models"
)

// Transactions is the resolver for the transactions field.
func (r *queryResolver) Transactions(ctx context.Context, limit *int, offset *int, contractAddress *string, fromAddress *string, toAddress *string, tokenName *string, fromBlock *int, toBlock *int) ([]*Transaction, error) {
	db := database.GetDB()
	query := db.Model(&models.Transaction{})
	
	// Apply filters
	if contractAddress != nil {
		query = query.Where("contract_address = ?", *contractAddress)
	}
	if fromAddress != nil {
		query = query.Where("from_address = ?", *fromAddress)
	}
	if toAddress != nil {
		query = query.Where("to_address = ?", *toAddress)
	}
	if tokenName != nil {
		query = query.Where("token_name = ?", *tokenName)
	}
	if fromBlock != nil {
		query = query.Where("block_number >= ?", *fromBlock)
	}
	if toBlock != nil {
		query = query.Where("block_number <= ?", *toBlock)
	}
	
	// Apply pagination
	if offset != nil {
		query = query.Offset(*offset)
	}
	if limit != nil {
		query = query.Limit(*limit)
	}
	
	var dbTransactions []models.Transaction
	if err := query.Order("block_number DESC, log_index DESC").Find(&dbTransactions).Error; err != nil {
		return nil, fmt.Errorf("failed to fetch transactions: %w", err)
	}
	
	// Convert to GraphQL types
	var transactions []*Transaction
	for _, tx := range dbTransactions {
		gqlTx := &Transaction{
			ID:              strconv.Itoa(int(tx.ID)),
			TxHash:          tx.TxHash,
			BlockNumber:     int(tx.BlockNumber),
			LogIndex:        int(tx.LogIndex),
			ContractAddress: tx.ContractAddress,
			TokenName:       tx.TokenName,
			FromAddress:     tx.FromAddress,
			ToAddress:       tx.ToAddress,
			Amount:          tx.Amount,
			BlockTimestamp:  tx.BlockTimestamp.Format("2006-01-02T15:04:05Z07:00"),
			CreatedAt:       tx.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
		}
		
		if tx.PriceUSD != nil {
			gqlTx.PriceUsd = tx.PriceUSD
		}
		if tx.ValueUSD != nil {
			gqlTx.ValueUsd = tx.ValueUSD
		}
		
		transactions = append(transactions, gqlTx)
	}
	
	return transactions, nil
}

// Transaction is the resolver for the transaction field.
func (r *queryResolver) Transaction(ctx context.Context, id string) (*Transaction, error) {
	panic(fmt.Errorf("not implemented: Transaction - transaction"))
}

// Contracts is the resolver for the contracts field.
func (r *queryResolver) Contracts(ctx context.Context) ([]*Contract, error) {
	panic(fmt.Errorf("not implemented: Contracts - contracts"))
}

// Contract is the resolver for the contract field.
func (r *queryResolver) Contract(ctx context.Context, address string) (*Contract, error) {
	panic(fmt.Errorf("not implemented: Contract - contract"))
}

// TransactionCount is the resolver for the transactionCount field.
func (r *queryResolver) TransactionCount(ctx context.Context, contractAddress *string) (int, error) {
	panic(fmt.Errorf("not implemented: TransactionCount - transactionCount"))
}

// AddressTransactions is the resolver for the addressTransactions field.
func (r *queryResolver) AddressTransactions(ctx context.Context, address string, limit *int, offset *int) ([]*Transaction, error) {
	panic(fmt.Errorf("not implemented: AddressTransactions - addressTransactions"))
}

// PriceHistory is the resolver for the priceHistory field.
func (r *queryResolver) PriceHistory(ctx context.Context, contractAddress string, interval string, from string, to string) ([]*PricePoint, error) {
	panic(fmt.Errorf("not implemented: PriceHistory - priceHistory"))
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
